# Redis 連接修復和持久化功能測試指南

## 已完成的工作

### 1. Redis 連接修復
- ✅ 手動配置 `RedisConnectionFactory`（使用連接池）
- ✅ 為 `RedisMessageListenerContainer` 創建專用連接工廠（非池化）
- ✅ 確保連接池正確初始化

### 2. Redis 持久化功能（使用 Lua 腳本）
- ✅ 創建 `save_message.lua` - 保存訊息的 Lua 腳本
- ✅ 創建 `get_messages.lua` - 獲取訊息的 Lua 腳本
- ✅ 創建 `ChatMessageService` - 訊息持久化服務
- ✅ 創建 `ChatHistoryController` - 歷史記錄 API
- ✅ 修改 `MessageController` - 添加訊息持久化調用

## 測試步驟

### 步驟 1：確認應用程式已啟動

```bash
# 檢查應用程式是否可訪問
curl http://localhost:8080/

# 應該返回 HTML 頁面
```

### 步驟 2：測試公共聊天室

1. **打開瀏覽器：**
   - 打開 `http://localhost:8080/agent-a.html`
   - 打開 `http://localhost:8080/agent-b.html`（新分頁）

2. **發送公共訊息：**
   - 在專員A頁面的「公共聊天室」輸入框輸入訊息
   - 點擊「發送」按鈕

3. **驗證：**
   - 專員A應該看到自己發送的訊息
   - 專員B應該也收到相同的訊息
   - 兩個頁面都應該顯示訊息

### 步驟 3：測試訊息持久化

**發送幾條訊息後，查詢歷史記錄：**

```bash
# 查詢公共訊息歷史（最新 10 條）
curl http://localhost:8080/api/chat/public?limit=10

# 回應範例：
# {
#   "success": true,
#   "messages": [
#     {
#       "senderId": "user123",
#       "senderName": "user123",
#       "content": "訊息內容",
#       "timestamp": 1234567890123,
#       "type": "public",
#       "recipientId": null
#     },
#     ...
#   ],
#   "count": 10,
#   "limit": 10,
#   "offset": 0
# }
```

### 步驟 4：測試私信持久化

1. **發送私信：**
   - 在專員A頁面，輸入專員B的用戶ID
   - 發送私信給專員B

2. **查詢私信歷史：**

```bash
# 查詢專員A的私信歷史（替換 {userId} 為實際的用戶ID）
curl "http://localhost:8080/api/chat/private?userId={userId}&limit=10"
```

### 步驟 5：驗證 Redis 存儲

```bash
# 檢查公共訊息數量
docker exec redis redis-cli ZCARD "chat:messages:public"

# 查看最新的公共訊息（JSON 格式）
docker exec redis redis-cli ZREVRANGE "chat:messages:public" 0 0

# 檢查私信訊息數量（替換 {userId} 為實際的用戶ID）
docker exec redis redis-cli ZCARD "chat:messages:private:{userId}"
```

## 預期結果

### 公共聊天室
- ✅ 訊息可以正常發送和接收
- ✅ 訊息已持久化到 Redis
- ✅ 可以通過 API 查詢歷史記錄

### 私信功能
- ✅ 私信可以正常發送和接收
- ✅ 私信已持久化到 Redis（為發送者和接收者分別保存）
- ✅ 可以通過 API 查詢歷史記錄

### Redis 連接
- ✅ `RedisTemplate` 可以正常連接（用於發布訊息和持久化）
- ✅ `RedisMessageListenerContainer` 可以正常連接（用於監聽 Pub/Sub）

## 檢查日誌

### 成功的日誌應該包含：

```
Redis 連接工廠已配置：host=localhost, port=6379, database=0, poolMaxActive=8, poolMaxIdle=8, poolMinIdle=0
RedisMessageListenerContainer 專用連接工廠已配置：host=localhost, port=6379, database=0（非池化）
=== 公共訊息接收 ===
發布到 Redis /topic/chat 頻道
公共訊息已發布到 Redis 並持久化
=== Redis 訊息接收 ===
✓ 訊息已轉發到 WebSocket /topic/chat 頻道
公共訊息已保存到 Redis：senderId=xxx, count=1
```

### 不應該看到的錯誤：

- ❌ `Unable to connect to localhost/<unresolved>:6379`
- ❌ `Could not get a resource from the pool`
- ❌ `RedisConnectionFailureException`

## 故障排除

### 如果公共聊天室仍然無法工作：

1. **檢查 Redis 連接：**
   ```bash
   docker exec redis redis-cli ping
   # 應該返回 PONG
   ```

2. **檢查應用程式日誌：**
   - 查看是否有 `Redis 連接工廠已配置` 日誌
   - 查看是否有 `Redis 訊息接收` 日誌

3. **檢查 Redis 中的資料：**
   ```bash
   # 檢查是否有訊息被保存
   docker exec redis redis-cli ZCARD "chat:messages:public"
   ```

### 如果 API 無法訪問：

1. **確認應用程式已啟動：**
   ```bash
   # 檢查日誌中是否有 "Started SpringBootStompApplication"
   ```

2. **檢查端口：**
   ```bash
   # 確認 8080 端口是否被占用
   netstat -ano | findstr :8080
   ```

## 功能總結

### Redis 使用情況

1. **Redis Pub/Sub** - 用於公共聊天室的即時廣播
2. **Redis Sorted Set** - 用於訊息持久化（使用 Lua 腳本）
3. **Redis Key-Value** - 用於客戶端狀態管理（心跳時間）

### RabbitMQ 使用情況

1. **RabbitMQ TTL + Dead Letter Queue** - 用於客戶端狀態檢查（延遲訊息）

### 持久化機制

- **公共訊息**：保存到 `chat:messages:public`（Sorted Set）
- **私信訊息**：保存到 `chat:messages:private:{userId}`（Sorted Set）
- **自動清理**：超過 1000 條自動刪除最舊的
- **自動過期**：30 天後自動刪除整個列表









