# WebSocket 私信功能問題分析

## 問題描述
專員A和專員B無法互相收到私信，訊息在伺服器端被處理但無法送達客戶端。

## 根本原因分析

### 問題 1：WebSocketConfig 配置衝突（關鍵問題）

**錯誤配置：**
```java
registry.enableSimpleBroker("/topic", "/user");
```

**問題說明：**
- `/user` 前綴應該由 `UserDestinationMessageHandler` 專門處理
- 當同時在 `enableSimpleBroker` 中啟用 `/user` 前綴時，會導致路由衝突
- `SimpleBrokerMessageHandler` 和 `UserDestinationMessageHandler` 會同時處理 `/user` 前綴的訊息
- 這導致訊息路由混亂，訊息無法正確發送到 `clientOutboundChannel`

**正確配置：**
```java
registry.enableSimpleBroker("/topic");  // 只啟用 /topic
registry.setUserDestinationPrefix("/user");  // /user 由 UserDestinationMessageHandler 處理
```

### 問題 2：用戶ID處理不當

**問題：**
- 用戶ID可能包含換行符（`\n`）、回車符（`\r`）或空字符（`\u0000`）
- 這些字符會導致 `UserDestinationMessageHandler` 無法正確匹配用戶會話

**解決方案：**
- 在前端和後端都對用戶ID進行清理
- 使用 `trim().replace(/[\n\r\u0000]/g, '')` 清理用戶ID

### 問題 3：出站訊息日誌不足

**問題：**
- 無法確認訊息是否通過 `clientOutboundChannel` 發送
- 缺少出站訊息的詳細日誌記錄

**解決方案：**
- 增強 `WebSocketInterceptor`，特別記錄出站訊息（MESSAGE 命令）
- 在 `preSend` 和 `afterSendCompletion` 中記錄出站訊息詳情

## 訊息流程分析

### 正確的私信流程

1. **客戶端發送：**
   ```
   專員B -> SEND /ws/privateMessage
   {
     "content": "訊息內容",
     "id": "專員A的用戶ID"
   }
   ```

2. **伺服器處理：**
   ```
   MessageController.privateMessage() 
   -> convertAndSendToUser(recipientId, "/topic/privateMessage", message)
   -> 轉換為 /user/{recipientId}/topic/privateMessage
   ```

3. **路由轉換：**
   ```
   UserDestinationMessageHandler 
   -> 將 /user/{recipientId}/topic/privateMessage 
   -> 轉換為 /topic/privateMessage-{sessionId}
   ```

4. **訊息發送：**
   ```
   SimpleBrokerMessageHandler 
   -> 查找訂閱 /topic/privateMessage-{sessionId} 的會話
   -> 發送到 clientOutboundChannel
   -> 客戶端收到 MESSAGE 命令
   ```

### 問題發生時的流程

1. **訊息被處理：**
   - `MessageController` 正確處理私信
   - `convertAndSendToUser` 被調用
   - 路徑轉換正確

2. **路由衝突：**
   - `SimpleBrokerMessageHandler` 和 `UserDestinationMessageHandler` 同時處理
   - 訊息無法正確路由到 `clientOutboundChannel`
   - 沒有出站訊息日誌（表示訊息未發送）

3. **結果：**
   - 伺服器日誌顯示訊息已處理
   - 但客戶端沒有收到訊息
   - 沒有出站訊息日誌

## 修正方案總結

### 1. WebSocketConfig.java
```java
// 修正前
registry.enableSimpleBroker("/topic", "/user");  // ❌ 錯誤

// 修正後
registry.enableSimpleBroker("/topic");  // ✅ 正確
registry.setUserDestinationPrefix("/user");  // ✅ 正確
```

### 2. MessageController.java
- 增加接收者ID的清理和驗證
- 使用 `trim()` 和 `replaceAll("[\\n\\r\\u0000]", "")` 清理用戶ID

### 3. WebSocketInterceptor.java
- 增強 `preSend` 方法，特別記錄出站訊息（ERROR 級別）
- 增強 `afterSendCompletion` 方法，記錄訊息發送狀態
- 新增 `postReceive` 方法，追蹤訊息接收

### 4. 前端（agent-a.html, agent-b.html）
- 清理從 `CONNECTED` 幀中提取的用戶ID
- 使用 `trim().replace(/[\n\r\u0000]/g, '')` 清理用戶ID

## 驗證方法

### 1. 檢查日誌
- 查看是否有 `=== 出站訊息攔截（preSend）===` 日誌
- 查看是否有 `✓✓✓ 私信已成功發送到 clientOutboundChannel` 日誌

### 2. 測試流程
1. 打開專員A頁面：`http://localhost:8080/agent-a.html`
2. 打開專員B頁面：`http://localhost:8080/agent-b.html`
3. 確認兩個專員都已連接
4. 專員B發送私信給專員A
5. 檢查專員A是否收到私信
6. 專員A發送私信給專員B
7. 檢查專員B是否收到私信

## 關鍵學習點

1. **Spring WebSocket 路由機制：**
   - `enableSimpleBroker` 用於公共頻道（如 `/topic/chat`）
   - `setUserDestinationPrefix` 用於用戶特定頻道（如 `/user/{userId}/topic/privateMessage`）
   - 兩者不應該重疊，否則會導致路由衝突

2. **UserDestinationMessageHandler 的作用：**
   - 將 `/user/{userId}/topic/xxx` 轉換為實際的訂閱路徑
   - 例如：`/user/abc123/topic/privateMessage` -> `/topic/privateMessage-{sessionId}`
   - 這樣可以實現用戶特定的訊息路由

3. **訊息追蹤的重要性：**
   - 出站訊息日誌對於調試非常重要
   - 可以確認訊息是否正確發送到客戶端
   - 幫助識別路由問題

## 結論

主要問題是 `WebSocketConfig` 中的配置衝突。當同時在 `enableSimpleBroker` 中啟用 `/user` 前綴時，會導致 `SimpleBrokerMessageHandler` 和 `UserDestinationMessageHandler` 的路由衝突，訊息無法正確發送到客戶端。

修正後，`/user` 前綴完全由 `UserDestinationMessageHandler` 處理，訊息可以正確路由到目標用戶的會話，私信功能正常工作。









